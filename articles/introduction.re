= GraphQLってなんなのさ

まずはGraphQLが何なのか、なぜ勉強してみるべきなのかを考えます。
GraphQLは銀の弾丸ではないですが、フロント側の開発体験を改善するものであると筆者は考えています。

GraphQLはGraph Query Languageの名のとおり、グラフ構造に対するクエリ言語です。
大本をFacebookが考案しただけあって、友人関係などのグラフ状のデータを（画面に描画のために）取得する言語といえます。
クエリの対象としてはグラフ構造（的な何か）ですが、レスポンスはツリー構造になります。

== GraphQLを用いる目的

GraphQLを用いる最大の目的は、クライアント側の設計とサーバ側の設計をよりよく分離することでしょう。

RESTfulなAPIの場合、1つの画面を描画するために複数回エンドポイントを叩くか、その画面専用のエンドポイントを1回叩くかするのが一般的です。
サーバ側設計をきれいに保つ代わりに何回ものリクエストが発生することを許容するか、オーバーヘッドをなくすためにサーバとクライアントが協力して複雑なことをするかのトレードオフが発生します。

一方、GraphQLでは1回のクエリで複数の値が取れたり、ネストした構造のデータも一度に取得することができます。
しかも、そのサーバ側の実装はある画面のための特別な実装ではなく、他の画面でも使い回せる共通のものなのです。
性能を追求する上で、クライアントとサーバが密接に協力しなくてもよい、疎な結合にしておけるのは大変に魅力的です。

== GraphQLって本当に使えるの？

筆者は使えると現在のところ考えています。
とはいえ、RESTfulなAPIと比べて目立ってシェアを奪いはじめている感じでもないですが…。
筆者としては、今後新しくシステムを組む場合、まずはGraphQLファーストで取り組んでみようかと考える程度には気に入っています。

もちろん、GraphQLは万能ではありませんので、RESFTfulなAPIを完全に廃止できるとは考えないほうがよいでしょう。
たとえば、バイナリファイルについての扱いについてはまだエコシステムが育っていないのもあり、効率よく扱うには大変な苦労があるでしょう。
よって、ファイルや画像のアップロードやダウンロードなどではGraphQLを使う価値は薄いでしょう。

=== クライアントから見た感想

よくあるクライアント側の誤解をここで揉みほぐしておきます。
画面を分割して統治するため、我々は部品として切り出しこれをコンポーネントとしていると思います。
「でも、各コンポーネントが自分の欲しいデータを得るために勝手にクエリ投げたら結局重たいじゃん？」
しかし、それは誤解です。

GraphQLにはFragmentという仕様があります。
各コンポーネントは自分が欲しいデータをFragmentとして定義し、上流のコンポーネントに流します。
最上位のコンポーネントはこれを総括し、単一のクエリとしてサーバに投げ、帰ってきたデータを下流に分配します。
この仕組により複数のコンポーネントがまさに自分の欲しいデータのみを要求し、かつ効率的に動作することができるのです。
画面をコンポーネントに分割して統治するのであれば、クエリも同様にFragmentに分割して統治するというわけです。

この仕組みは本当に正しくて、クライアント側が実際使っているフィールドはどこなのか？という問題をうまく解決しています。
Fragmentを使わずに効率的にやろうとした場合、結局クエリに下流のコンポーネントの要求をひたすらべた書きしなければなりません。
すると、下流のどのコンポーネントがどの値を使っているかがわからくて下手にクエリを削れない！…ということになりかねません。

=== サーバから見た感想

サーバから見た感想としては、満たすべき仕様がちょいちょい多くあってつらい場面もありますが、基本的には楽になると言ってよいでしょう。
@<chapref>{best-practice}で詳しく述べますが、RESTfulなAPIは実質@<kw>{RPC,Remote Procedure Call}です。
一方、GraphQLはその名の示すとおりQuery Languageです。
この差はかなり大きく、RESTful APIを実装するサーバ側コードを流用しようとするとクライアント側から見て理解に苦しむ挙動になりがちです。

また、アクセス権限を絞ったりするのにはDirectiveという仕様の存在が大きいです。
実際に自分でGraphQLサーバを構成してみると、GET系の処理についてはDB+Directiveで設計したルールベースの制御だけで賄える気すらしています。
もしかしたら、prisma@<fn>{prisma}のようなGraphQL特化の@<kw>{ORM,Object Relation Mapping}というのは筋のよい考え方なのかもしれません。
自分は使わないと思いますが…。

//footnote[prisma][@<href>{https://www.prisma.io/}]

== Introspectionがつよい

Introspection（自己観察）が強いです。
GraphQLは色々なデータに対してクエリを投げ、結果を取得することができます。
この構造はメタ的なデータについても同様で、あるGraphQLサーバがどういうオペレーションを持ち、どういう型があり、それらがどういうフィールドをもつのかをクエリで調べることができます。
いわゆるリフレクション的なことができるのです。

この構造はかなり強く、多くのツールがこの機能をフルに活用しています。
なんなら、関連仕様の記述もIntrospectionからの返り値をコピペして済ませている箇所すらあります。
つよい！

GraphQLはきっちりと型付けされていて、しかもその情報をサーバから引き出せるわけですのでWeb UIなども非常に洗練されていて使い心地がよいです。
そしてクエリも投げる前にサーバが受付可能であるかを事前にチェックするため、多くの実行時エラーを減らすことに成功しています。

== 一瞬で腑に落ちるGraphQLサーバの概念

筆者がGraphQLの勉強を始めた時に最初に知りたかったことを書いておきます。
それは、GraphQLサーバの実装はResolverの集合体であるということです。

技術書典のデータ構造を例に考えてみます。
まず最初にEvent（イベント）があり、その下にCircleExhibitInfo（サークル参加情報）があり、さらにその下にProductInfo（頒布物情報）があります。
クエリにあわせ、まず最初にイベントをresolve（解決）し、それにぶら下がる数百のサークルをresolveし、各サークル毎に1〜n個の頒布物情報をresolveします。
ここでそれぞれにResolverを定義します。
1. クエリ→イベントのResolver、2. イベント→サークルリストのResolver、3. サークル→頒布物リストのResolver という感じです。
そして、これらすべてのResolverを統合したものがGraphQLサーバなのです。

ResolverがNodeを生成し、Nodeがツリー構造を成し、これがレスポンスとなるのです。
よって、GraphQLサーバとはどうやってResolverを定義するか、そしてそれを統合するか、という問題に還元されていきます。

順当に考えると、Facebookが抱えるような"友達の友達"という構造に対して全データを取得しようとするのは危険です。
友達の友達には循環構造が含まれるため、再帰的に処理し続けると無限ループになることは想像に難くありません。
そこで、クライアントから求めたデータ構造にマッチするよう、クエリドリブンで動作するResolverが妥当なわけです。

== GraphQLの勉強の仕方

とりあえず@<href>{https://www.howtographql.com/}を読むのがいいと思います。
そして仕様@<fn>{graphl-spec}も読むとよいでしょう。
GraphQLの仕様は転送方法レベルの話はないのでざっくり斜め読みでよいでしょう。
何ならAppendixのGrammar Summaryだけでもよいかもしれません。

//footnote[graphl-spec][@<href>{https://facebook.github.io/graphql/}]

市井の記事はクライアント側の話に偏っているため、サーバ側の知見はわりと自分で試して覚えろ的なところがあります。
また、Node.jsやRubyでの事例が多いため、gqlgenについてはこれからといえそうです。
やっていきましょう。
@<href>{https://gitter.im/gqlgen/Lobby}に公式のチャットルームがあるので活用するとよいでしょう。

筆者が今まで勉強してきた軌跡は@<href>{http://b.hatena.ne.jp/vvakame/GraphQL}にあります。
また、Mercari Tech Conf 2018のサイトでもgqlgenを使っています。
このソースは@<href>{https://github.com/mercari/mtc2018-web}で公開しているので、眺めてみるのもよいでしょう。

//comment{
TODO
https://github.com/mercari/mtc2018-web/pull/134 とか mtcで色々試したことについて言及する
//}
