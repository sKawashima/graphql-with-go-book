= GraphQLってなんなのさ

まずはGraphQLが何なのか、なぜ勉強してみるべきなのかを考えます。
GraphQLは銀の弾丸ではないですが、フロント側の開発体験を改善するものであると筆者は考えています。

GraphQLはGraph Query Languageの名のとおり、グラフ構造に対するクエリ言語です。
大本をFacebookが考案しただけあって、友人関係などのグラフ構造を画面に描画するために取得するための言語と言えます。
クエリの対象としてはグラフ構造（的な何か）ですが、レスポンスはツリー構造になります。

== GraphQLを用いる目的

GraphQLを用いる最大の目的は、クライアント側の設計とサーバ側の設計をよりよく分離することでしょう。

RESTfulなAPIの場合、1つの画面を描画するために複数回エンドポイントを叩くか、その画面専用のエンドポイントを1回叩くかするのが一般的です。
これは、サーバ側設計をきれいに保つ代わりに何回ものリクエストが発生することを許容するか、オーバーヘッドをなくすためにサーバとクライアントが協力して複雑なことをするかのトレードオフが発生するということです。

一方、GraphQLでは1回のクエリで複数の値が取れたり、ネストした構造のデータも一度に取得することができます。
しかも、そのサーバ側の実装はある画面のための特別な実装ではなく、他の画面でも使い回せる共有のものなのです。
性能を追求する上で、クライアントとサーバが密接に協力しなくてもよい、疎な結合にしておけるのは大変に魅力的です。

== GraphQLって本当に使えるの？

筆者は使えると現在のところ考えています。
とはいえ、RESTfulなAPIと比べて目立ってシェアを奪いはじめている感じでもないですが…。
筆者としては、今後新しくシステムを組む場合、まずはGraphQLファーストで取り組んでみようかと考える程度には気に入っています。

もちろん、GraphQLは万能ではありませんので、RESFTfulなAPIを完全に廃止できるとは考えないほうがよいでしょう。
たとえば、バイナリファイルについての扱いについてはまだエコシステムが育っていないのもあり、効率よく扱うには大変な苦労があるでしょう。
よって、ファイルや画像のアップロードやダウンロードなどではGraphQLを使う価値は薄いでしょう。

=== クライアントから見た感想

よくあるクライアント側の誤解をここで揉みほぐしておきます。
画面を分割して統治するため、我々は部品として切り出しこれをコンポーネントとしていると思います。
「でも、各コンポーネントが自分の欲しいデータを得るために勝手にクエリ投げたら結局重たいじゃん？」
しかし、それは誤解です。

GraphQLにはFragmentという仕様があります。
各コンポーネントは自分が欲しいデータをFragmentとして定義し、上流のコンポーネントに流します。
最上位のコンポーネントはこれを総括し、単一のクエリとしてサーバに投げ、帰ってきたデータを下流に分配します。
この仕組により複数のコンポーネントがまさに自分の欲しいデータのみを要求し、かつ効率的に動作することができるのです。
画面をコンポーネントに分割して統治するのであれば、クエリも同様にFragmentに分割して統治するというわけです。

この仕組みは本当に正しくて、クライアント側が本当に欲しいフィールドは、使っているフィールドはどこなのか？という問題をうまく解決しています。
Fragmentを使わずに効率的にやろうとした場合、結局クエリがファットにならざるを得ません。
すると、下流のどのコンポーネントが何を使っているかがわからないので結局クエリを変更しづらい…ということになりかねません。

=== サーバから見た感想

サーバから見た感想としては、満たすべき仕様がちょいちょい多くあってつらい場面もありますが、基本的には楽になると言ってよいでしょう。
@<chapref>{best-practice}で詳しく述べますが、RESTfulなAPIは実質@<kw>{RPC,Remote Procedure Call}です。
一方、GraphQLはその名の示すとおりQuery Languageです。
この差はかなり大きく、RESTful APIと同じコードを流用しようとするとクライアント側から見て理解に苦しむ挙動になりがちです。

また、アクセス権限を絞ったりするのにはDirectiveという仕様の存在が大きいです。
実際に自分でGraphQLサーバを構成してみると、DBとDirectiveという形で設計したルールベースの制御だけで賄える気すらしています。
もしかしたら、prisma@<fn>{prisma}のようなGraphQL特化の@<kw>{ORM,Object Relation Mapping}というのは筋のよい考え方なのかもしれません。
自分は使わないと思いますが…。

//footnote[prisma][@<href>{https://www.prisma.io/}]

== GraphQLの特性

TODO 何書こうとしたんだっけ…？

== 一瞬で腑に落ちるGraphQLサーバの概念

この章の最後に、筆者がGraphQLの勉強を始めた時に最初に知りたかったことを書いておきます。
それは、GraphQLサーバの実装はResolverの集合体であるということです。

技術書典のデータ構造を例に考えてみます。
まず最初にEvent（イベント）があり、その下にCircleExhibitInfo（サークル参加情報）があり、さらにその下にProductInfo（頒布物情報）があります。
クエリにあわせ、まず最初にイベントをresolve（解決）し、それにぶら下がる数百のサークルをresolveし、各サークル毎に1〜n個の頒布物情報をresolveします。
ここでそれぞれにResolverを定義します。
クエリ→イベントのResolver、イベント→サークルリストのResolver→、サークル→頒布物リストのResolver、これらを統合したものがGraphQLサーバなのです。

ResolverがNodeを生成し、Nodeがツリー構造を成し、これがレスポンスとなるのです。
よって、GraphQLサーバとはどうやってResolverを定義するか、そしてそれを統合するか、という問題に還元されていきます。

順当に考えると、Facebookが抱えるような"友達の友達"という構造に対して雑にクエリを投げるのは危険です。
友達の友達には大本の人間が（たぶん）含まれるため、再帰的に無限ループになることは想像に難くありません。
そこで、クライアントから求めた構造にマッチするよう、クエリドリブンで実行するResolverが選択される必要があるというわけです。
